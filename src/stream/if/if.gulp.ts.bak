
import ForkStream from 'fork-stream';
import mergeStream from 'merge2';
import duplexify from 'duplexify';
import minimatch from 'minimatch';
import stream from 'stream';
import VinylFile from 'vinyl';
import PluginError from 'plugin-error';
import through from 'through2';
import match from 'gulp-match';
import { ReadableStream, WritableStream, Stream } from '../types';
import { TT$, AnyFunction } from '@upradata/util';
import { isPromise } from '../common';

export interface StatFilterCondition {
    isDirectory?: boolean;
    isFile?: boolean;
}

export type IfCondition = boolean | StatFilterCondition | ((fs: VinylFile) => boolean);

export type ReadableWritableStream = ReadableStream & WritableStream;
export type IfStream = TT$<ReadableWritableStream> | TT$<(source: ReadableStream) => TT$<ReadableWritableStream>>;


export interface GulpIfOptions {
    condition: IfCondition;
    true: IfStream;
    false?: IfStream;
    minimatchOptions?: minimatch.IOptions;
}

export function gulpIf(options: GulpIfOptions) {
    const { condition, true: trueStream, false: falseStream, minimatchOptions } = options;

    if (!trueStream) {
        throw new Error('gulp-if: child action is required');
    }

    if (typeof condition === 'boolean') {
        // no need to evaluate the condition for each file
        // other benefit is it never loads the other stream
        return condition ? trueStream : (falseStream || through.obj());
    }

    const classifier = (file: VinylFile) => {
        return !!match(file, condition, minimatchOptions);
    };

    return ternaryStream({ condition: classifier, trueStream, falseStream });
}


export type TypeOfTT$<U> = U extends Promise<infer V> ? V : U;


export function ternaryStream<IFStream extends IfStream>(options: { condition: (data: any) => boolean, trueStream: IFStream, falseStream?: IFStream; }):
    IFStream extends TT$<ReadableWritableStream> ? IFStream :
    IFStream extends AnyFunction ? ReturnType<IFStream> : Promise<ReadableWritableStream> {
    /*  extends ReadableWritableStream ? ReadableWritableStream : Promise<ReadableWritableStream> :
    IFStream extends ReadableWritableStream ? ReadableWritableStream : Promise<ReadableWritableStream> { */

    const { condition, trueStream, falseStream } = options;

    if (!trueStream) {
        throw new PluginError('TernaryStream', 'true stream is required');
    }

    if (isPromise<any>(trueStream)) {
        const falseStreamPromise = falseStream ? isPromise<any>(falseStream) ? falseStream : Promise.resolve(falseStream as any) : Promise.resolve();

        Promise.all([ trueStream, falseStreamPromise ]).then(([ trueS, falseS ]) => {

        });
    }


}

function createTernary(options: { condition: (data: any) => boolean, trueStream: TypeOfTT$<IfStream>, falseStream?: TypeOfTT$<IfStream>; }) {

    const { condition, trueStream, falseStream } = options;

    // output stream
    const outStream = through.obj();

    // create fork-stream
    const forkStream = new ForkStream({
        classifier: (e, cb) => {
            const ans = !!condition(e);
            return cb(null, ans);
        }
    });

    // if condition is true, pipe input to trueStream
    if (typeof trueStream === 'function')
        trueStream(forkStream.a);
    else
        forkStream.a.pipe(trueStream);

    let mergedStream: stream.Transform = undefined;

    if (falseStream) {
        // if there's an 'else' condition
        // if condition is false
        // pipe input to falseStream
        forkStream.b.pipe(falseStream);
        // merge output with trueStream's output
        mergedStream = mergeStream(falseStream, trueStream);
        // redirect falseStream errors to mergedStream
        falseStream.on('error', err => mergedStream.emit('error', err));
    } else {
        // if there's no 'else' condition
        // if condition is false
        // merge output with trueStream's output
        mergedStream = mergeStream(forkStream.b, trueStream);
    }

    // redirect trueStream errors to mergedStream
    trueStream.on('error', err => mergedStream.emit('error', err));

    // send everything down-stream
    mergedStream.pipe(outStream);
    // redirect mergedStream errors to outStream
    mergedStream.on('error', err => outStream.emit('error', err));

    // consumers write in to forkStream, we write out to outStream
    return duplexify.obj(forkStream, outStream);
}
